import os.path
import random

configfile: "config.assembly.yml"

# rule 'all' builds specific SBTs.
rule all:
  input:
    expand("outputs/sbt/{db}-{domain}-x{bfsize}-k{ksize}.sbt.zip", db=config['db'], ksize=config['db_ksizes'], domain=config['domains'], bfsize=config['bfsize']),
#    expand("outputs/lca/{db}-{domain}-k{ksize}-scaled10k.lca.json.gz", db=config['db'], domain=config['domains'], ksize=config['db_ksizes'])


def sigs_in_catalog(w):
    with checkpoints.catalog.get(domain=w.domain, db=w.db).output[0].open('r') as f:
        return [l.strip() for l in f.readlines()]


rule sbt:
  output: "outputs/{index}/{db}-{domain}-x{bfsize}-k{ksize}.sbt.zip"
  input:
    catalog = "outputs/catalog/{domain}/{db}.txt",
    sigs = sigs_in_catalog
  params:
    ksize="{ksize}",
    db="{db}",
    domain="{domain}",
    bfsize="{bfsize}",
  shell: """
    sourmash index \
      -k {params.ksize} \
      -x {params.bfsize} \
      --from-file <(tail +1 {input.catalog}) \
      {output} $(head -1 {input.catalog})
    """

rule lca:
  output: "outputs/lca/{db}-{domain}-k{ksize}-scaled10k.lca.json.gz",
  input:
    lineage="domain-{domain}.acc.lineages.csv"
  params:
    ksize="{ksize}",
    db="{db}",
    domain="{domain}",
    config="{config}"
  shell: """
    sourmash lca index \
      -k {params.ksize} \
      --scaled 10000 \
      --report report-lca-{params.db}-{params.domain}-{params.ksize}.txt \
      --traverse-directory -C 3 --split-identifiers \
      domain-{params.domain}.acc.lineages.csv \
      {output} outputs/sigs/{params.config}/{params.db}/{params.domain}
  """

rule download_catalog:
  output:
    catalog="outputs/assembly_stats/{domain}/assembly_summary_{db}.txt.gz",
    generated="outputs/assembly_stats/{domain}/assembly_summary_{db}.timestamp",
  params:
    domain="{domain}",
    db="{db}"
  shell: """
    wget --header='Accept-Encoding: gzip' -O {output.catalog} https://ftp.ncbi.nlm.nih.gov/genomes/{params.db}/{params.domain}/assembly_summary.txt
    date +%Y%m%d > {output.generated}
  """

checkpoint catalog:
  output: "outputs/catalog/{domain}/{db}.txt"
  input: "outputs/assembly_stats/{domain}/assembly_summary_{db}.txt.gz"
  params:
    domain = "{domain}"
  run:
      import csv
      import gzip

      basedir = config['sig_store']

      with gzip.open(input[0], 'rt') as fp:
          fp.readline() # skip first line
          fp.read(2) # skip initial comment in header
          data = csv.DictReader(fp, delimiter='\t')

          with open(output[0], 'w') as fout:
              for row in data:
                  accession = row['assembly_accession']
                  path = f"{basedir}/{accession}.sig"
                  if not os.path.exists(path):
                      # let's calculate locally
                      path = f"outputs/sigs/{params.domain}/{accession}.sig"
                  fout.write(path + '\n')


## Rules for computing signatures not found in config['sig_store']

def url_for_accession(accession):
    db, acc = accession.split("_")
    number, version = acc.split(".")
    number = "/".join([number[pos:pos + 3] for pos in range(0, len(number), 3)])
    url = f"ftp://ftp.ncbi.nlm.nih.gov/genomes/all/{db}/{number}"

    all_names = shell(f"curl -l {url}/", read=True).split('\n')

    full_name = None
    for name in all_names:
        db_, acc_, _ = name.split("_")
        if db_ == db and acc == acc_:
            full_name = name
            break

    url = "https" + url[3:]
    return f"{url}/{full_name}/{full_name}_genomic.fna.gz"

    # TODO: alternative is read assembly_summary for asm_name
    #return f"{url}/{accession}_{asm_name}"


def name_for_accession(domain, accession):
    import csv
    import gzip

    if accession[:3] == "GCA":
        db = "genbank"
    else:
        db = "refseq"
    summary = f"outputs/assembly_stats/{domain}/assembly_summary_{db}.txt.gz"

    with gzip.open(summary, 'rt') as fp:
        fp.readline() # skip first line
        fp.read(2) # skip initial comment in header
        data = csv.DictReader(fp, delimiter='\t')
        for row in data:
            if row['assembly_accession'] == accession:
                name_parts = [row["assembly_accession"], " ", row['organism_name']]
                if row['infraspecific_name']:
                    name_parts += [" ", row['infraspecific_name']]
                name_parts += [', ', row['asm_name']]
                return "".join(name_parts)
        # If we get here, then the accession wasn't in the summary.
        raise ValueError("Accession not in this summary file!")


# TODO: fix the input, need to calculate genbank/refseq from accession
rule compute:
  output: "outputs/sigs/{domain}/{accession}.sig"
  input:
    genbank="outputs/assembly_stats/{domain}/assembly_summary_genbank.txt.gz",
    refseq="outputs/assembly_stats/{domain}/assembly_summary_refseq.txt.gz",
  params:
    ksizes=lambda w: ",".join(str(k) for k in config["db_ksizes"]),
    scaled=1000,
    name=lambda w: name_for_accession(w.domain, w.accession),
    url_path=lambda w: url_for_accession(w.accession),
  shell: """
    sourmash compute -k {params.ksizes} \
      --scaled {params.scaled} \
      --track-abundance \
      --name {params.name:q} \
      -o {output} \
      <(curl {params.url_path} | zcat)
  """
